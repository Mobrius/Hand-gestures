<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>Virtual Lab – Alberi, Supporti e Cuscinetti (Gesture)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #050811;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      height: 100%;
    }
    #hud {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 13px;
      max-width: 270px;
      pointer-events: none;
    }
    #hud h1 {
      font-size: 16px;
      margin: 0 0 6px 0;
    }
    #hud p {
      margin: 4px 0;
      line-height: 1.3;
    }
    #status {
      font-size: 12px;
      margin-top: 6px;
      opacity: 0.9;
    }
    #btnWebcam {
      margin-top: 6px;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 4px;
      border: none;
      background: #1d3557;
      color: #f1faee;
      cursor: pointer;
      pointer-events: auto; /* importante: il bottone deve ricevere click */
    }
    #btnWebcam:active {
      transform: scale(0.97);
    }
  </style>
</head>
<body>
  <div id="hud">
    <h1>Virtual Lab – Alberi e Cuscinetti</h1>
    <p><strong>Controlli di test (mouse/tastiera)</strong></p>
    <p>
      – Trascina con il mouse per ruotare la vista<br>
      – Rotellina per zoom<br>
      – Tasto <code>E</code> per vista esplosa / normale
    </p>
    <p id="modeInfo">Modalità: <strong>Camera</strong></p>
    <p id="explodeInfo">Vista: <strong>Compatta</strong></p>
    <div id="status">
      Webcam: <span id="camStatus">in attesa avvio</span><br>
      Gesture attuale: <span id="gestureStatus">none</span>
    </div>
    <button id="btnWebcam">Attiva webcam</button>
  </div>

  <!-- Three.js core -->
  <script src="https://unpkg.com/three@0.161.0/build/three.min.js"></script>
  <!-- GLTFLoader (per quando vorrai usare modelli .glb da Sketchfab) -->
  <script src="https://unpkg.com/three@0.161.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    console.log('Supporto mediaDevices:', !!navigator.mediaDevices);

    // ========================================
    // 1. SCENA 3D – Setup base
    // ========================================
    let scene, camera, renderer;
    let assemblyGroup;
    let isExploded = false;
    let explodeProgress = 0; // 0 compatta, 1 esplosa

    // Camera orbit (controllata da mouse / gesture)
    let camRadius = 6;
    let camTheta = Math.PI / 6;  // rotazione intorno all'asse verticale
    let camPhi   = Math.PI / 4;  // altezza

    // Mouse controls di emergenza / test
    let isMouseDown = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    const parts = []; // conterrà i pezzi dell'assembly

    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050811);

      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 100);
      updateCameraPosition();

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // Luci
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x202030, 0.8);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
      dirLight.position.set(5, 10, 7);
      scene.add(dirLight);

      const fillLight = new THREE.PointLight(0x88aaff, 0.5, 50);
      fillLight.position.set(-6, 4, -4);
      scene.add(fillLight);

      // Pavimento
      const groundGeo = new THREE.PlaneGeometry(20, 20, 10, 10);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x101420,
        metalness: 0.1,
        roughness: 0.9
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -1.2;
      scene.add(ground);

      createMechanicalAssembly();

      window.addEventListener('resize', onWindowResize);

      // Controlli mouse (solo test)
      renderer.domElement.addEventListener('mousedown', onMouseDown);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
      renderer.domElement.addEventListener('wheel', onMouseWheel);

      // Tasto 'E' per esploso
      window.addEventListener('keydown', (e) => {
        if (e.key === 'e' || e.key === 'E') {
          toggleExplode();
        }
      });
    }

    function updateCameraPosition() {
      const x = camRadius * Math.cos(camPhi) * Math.sin(camTheta);
      const y = camRadius * Math.sin(camPhi);
      const z = camRadius * Math.cos(camPhi) * Math.cos(camTheta);
      camera.position.set(x, y, z);
      camera.lookAt(0, 0, 0);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ========================================
    // 2. CREAZIONE ASSEMBLY MECCANICO SEMPLIFICATO
    // ========================================
    function createMechanicalAssembly() {
      assemblyGroup = new THREE.Group();
      scene.add(assemblyGroup);

      // Materiali base
      const steelMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        metalness: 0.8,
        roughness: 0.2
      });
      const darkSteelMat = new THREE.MeshStandardMaterial({
        color: 0x555566,
        metalness: 0.8,
        roughness: 0.3
      });
      const supportMat = new THREE.MeshStandardMaterial({
        color: 0x264653,
        metalness: 0.3,
        roughness: 0.8
      });

      // Albero (shaft)
      const shaftGeo = new THREE.CylinderGeometry(0.2, 0.2, 4, 32);
      const shaft = new THREE.Mesh(shaftGeo, steelMat);
      shaft.rotation.z = Math.PI / 2;
      shaft.name = "shaft";
      assemblyGroup.add(shaft);
      parts.push({
        mesh: shaft,
        compactPos: new THREE.Vector3(0, 0, 0),
        explodedOffset: new THREE.Vector3(0, 0.2, 0)
      });

      // Cuscinetti – torus
      const bearingGeo = new THREE.TorusGeometry(0.45, 0.12, 16, 32);
      const bearing1 = new THREE.Mesh(bearingGeo, darkSteelMat);
      bearing1.rotation.y = Math.PI / 2;
      bearing1.position.x = -1;
      bearing1.name = "bearing_left";
      assemblyGroup.add(bearing1);
      parts.push({
        mesh: bearing1,
        compactPos: bearing1.position.clone(),
        explodedOffset: new THREE.Vector3(-0.6, 0, 0)
      });

      const bearing2 = new THREE.Mesh(bearingGeo, darkSteelMat);
      bearing2.rotation.y = Math.PI / 2;
      bearing2.position.x = 1;
      bearing2.name = "bearing_right";
      assemblyGroup.add(bearing2);
      parts.push({
        mesh: bearing2,
        compactPos: bearing2.position.clone(),
        explodedOffset: new THREE.Vector3(0.6, 0, 0)
      });

      // Supporti
      const supportGeo = new THREE.BoxGeometry(1.2, 0.6, 1);
      const support1 = new THREE.Mesh(supportGeo, supportMat);
      support1.position.set(-1, -0.5, 0);
      support1.name = "support_left";
      assemblyGroup.add(support1);
      parts.push({
        mesh: support1,
        compactPos: support1.position.clone(),
        explodedOffset: new THREE.Vector3(-0.8, -0.1, 0)
      });

      const support2 = new THREE.Mesh(supportGeo, supportMat);
      support2.position.set(1, -0.5, 0);
      support2.name = "support_right";
      assemblyGroup.add(support2);
      parts.push({
        mesh: support2,
        compactPos: support2.position.clone(),
        explodedOffset: new THREE.Vector3(0.8, -0.1, 0)
      });

      // (Quando vorrai usare un modello reale .glb, puoi usare GLTFLoader qui)
      // const loader = new THREE.GLTFLoader();
      // loader.load('assets/models/mech_assembly.glb', (gltf) => {
      //   const model = gltf.scene;
      //   model.position.set(0, 0, 0);
      //   assemblyGroup.add(model);
      // }, undefined, (err) => {
      //   console.error('Errore loading GLB:', err);
      // });
    }

    function updateExplodePositions() {
      for (const p of parts) {
        const targetPos = new THREE.Vector3().copy(p.compactPos)
          .add(p.explodedOffset.clone().multiplyScalar(explodeProgress));
        p.mesh.position.copy(targetPos);
      }
    }

    function toggleExplode() {
      isExploded = !isExploded;
      document.getElementById('explodeInfo').innerHTML =
        'Vista: <strong>' + (isExploded ? 'Esplosa' : 'Compatta') + '</strong>';
    }

    // ========================================
    // 3. MOUSE CONTROLS (test)
    // ========================================
    function onMouseDown(e) {
      isMouseDown = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    }

    function onMouseMove(e) {
      if (!isMouseDown) return;
      const dx = e.clientX - lastMouseX;
      const dy = e.clientY - lastMouseY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;

      rotateCameraByDelta(dx, dy);
    }

    function onMouseUp() {
      isMouseDown = false;
    }

    function onMouseWheel(e) {
      zoomCamera(e.deltaY * 0.01);
    }

    function rotateCameraByDelta(dx, dy) {
      const ROT_SPEED = 0.005;
      camTheta -= dx * ROT_SPEED;
      camPhi   -= dy * ROT_SPEED;

      const EPS = 0.1;
      camPhi = Math.max(EPS, Math.min(Math.PI - EPS, camPhi));

      updateCameraPosition();
    }

    function zoomCamera(amount) {
      camRadius += amount;
      camRadius = Math.max(3, Math.min(15, camRadius));
      updateCameraPosition();
    }

    // ========================================
    // 4. Webcam “nascosta” e HAND TRACKING hook
    // ========================================
    const handState = {
      gesture: 'none', // 'rotate', 'zoom', 'explodeToggle', ecc.
      normX: 0,
      normY: 0
    };

    let hiddenVideo = null;
    let webcamStarted = false;

    function initWebcam() {
      if (webcamStarted) {
        console.log('Webcam già avviata');
        return;
      }

      const camStatusEl = document.getElementById('camStatus');

      hiddenVideo = document.createElement('video');
      hiddenVideo.autoplay = true;
      hiddenVideo.playsInline = true;
      hiddenVideo.muted = true;
      hiddenVideo.style.display = 'none';
      document.body.appendChild(hiddenVideo);

      if (!navigator.mediaDevices) {
        console.warn('navigator.mediaDevices NON presente (controlla HTTPS / origine sicura)');
        camStatusEl.textContent = 'non supportata (no mediaDevices)';
        return;
      }

      if (!navigator.mediaDevices.getUserMedia) {
        console.warn('navigator.mediaDevices.getUserMedia NON presente');
        camStatusEl.textContent = 'non supportata (no getUserMedia)';
        return;
      }

      camStatusEl.textContent = 'richiesta permesso...';

      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
          hiddenVideo.srcObject = stream;
          webcamStarted = true;
          camStatusEl.textContent = 'attiva (permesso OK)';
          console.log('Webcam attivata');
          // QUI AGGANCERAI MEDIAPIPE / TF.JS, usando hiddenVideo come sorgente
          // es: hands.send({image: hiddenVideo});
        })
        .catch(err => {
          console.error('Errore getUserMedia', err);
          camStatusEl.textContent = 'errore attivazione (vedi console)';
        });
    }

    // Chiamata che dovrà essere usata dal sistema di hand-tracking
    function handleHandInput(gesture, normX, normY) {
      handState.gesture = gesture;
      handState.normX = normX;
      handState.normY = normY;
      document.getElementById('gestureStatus').textContent =
        gesture + ' (' + normX.toFixed(2) + ', ' + normY.toFixed(2) + ')';
    }

    function applyHandControls(deltaTime) {
      if (handState.gesture === 'rotate') {
        const dx = handState.normX * 50 * deltaTime;
        const dy = handState.normY * 50 * deltaTime;
        rotateCameraByDelta(dx, dy);
      } else if (handState.gesture === 'zoom') {
        const amount = -handState.normY * deltaTime * 5;
        zoomCamera(amount);
      } else if (handState.gesture === 'explodeToggle') {
        toggleExplode();
        handState.gesture = 'none'; // reset per evitare triggering continuo
      }
    }

    // ========================================
    // 5. LOOP DI ANIMAZIONE
    // ========================================
    let lastTime = performance.now();

    function animate(now) {
      requestAnimationFrame(animate);
      const deltaTime = (now - lastTime) / 1000;
      lastTime = now;

      const target = isExploded ? 1 : 0;
      const speed = 3;
      if (Math.abs(explodeProgress - target) > 0.001) {
        explodeProgress += (target - explodeProgress) * Math.min(1, speed * deltaTime);
        explodeProgress = THREE.MathUtils.clamp(explodeProgress, 0, 1);
        updateExplodePositions();
      }

      applyHandControls(deltaTime);
      renderer.render(scene, camera);
    }

    // ========================================
    // 6. AVVIO
    // ========================================
    window.addEventListener('load', () => {
      initScene();
      updateExplodePositions();
      animate(performance.now());

      const btn = document.getElementById('btnWebcam');
      btn.addEventListener('click', () => {
        initWebcam();
      });
    });

    // Per test rapido dalla console:
    // handleHandInput('rotate', 0.3, 0.0);
    // handleHandInput('zoom', 0.0, -0.5);
    // handleHandInput('explodeToggle', 0, 0);
  </script>
</body>
</html>
